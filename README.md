# Spring Security Demo Project

## Dependency
- Only dependencies you need to write for our first project are spring-boot-starter-web and spring-boot-starter-security
![img_10.png](img_10.png)

## NOTE
- Spring Boot scans for components only in the package (and its sub-packages) that contains the class annotated with @SpringBootApplication
- If you annotate classes with any of the stereotype components in Spring, outside the main package, you must explicitly declare the location using the @ComponentScan annotation
- The @RestController annotation registers the bean in the context and tells Spring that the application uses this instance as a web controller. Also, the annotation specifies that the application has to set the @ResponseBody of the HTTP response from the method's return value.
- The @GetMapping annotation maps the /hello path to the implemented method through a GET request.

## Theory
- **HTTP Basic**: is a way a web app authenticates a user by means of a set of credentials (username and password) that the app gets in the header of the HTTP request
- **HTTPS**: There are several patters to configure HTTPS in a system. In some case. developers configure HTTPS at the application level; in others, t hey might use a service mesh or they could choose to set HTTPS at the infrastructure level.
  - In any of these configuration scenarios, you need a certificate signed by a certification authority (CA). Using this certificate, the client that calls the endpoint knows whether the response comes from the authentication server and that nobody intercepted the communication.
  - You can buy such a certificate, if you need it. If you only need to configure HTTPS to test your application, you can generate a self-signed certificate using a tool like OpenSSL
    - openssl req -newkey rsa:2048 -x509 -keyout key.pen -out cert.pem
    - After running the openssl command in a terminal, you'll be asked for a password and details about your CA. Because it is only a self-signed certificate for a test, you can input any data there; remember the password
    - The command outputs two files: key.pem (the private key) amd cert.pem (a public certificate). We'll use these files further to generate our self-signed certificate for enabling HTTPS. 
    - In most cases, the certificate is the Public Key Cryptography Standards #12 (PKCS12). Less frequently, we use a Java KeyStore(JKS) format.
      - PKCS12 format: openssl pkcs12 -export -in cert.pem -inkey key.pem -out certificate
      - This second command we use receives as input the two files generated by the first command and outputs the self-signed certificate.
## 1. Default Spring Security Configuration
- Once you run the application, besides the other lines in the console, you should see something that looks similar to this : Using generated security password: 93a01cf0-794b-4b98-86ef-54860f
- Each time you run the application, it generates a new password and prints this password in the console as presented in the previous code snippet. You must use this password to call any of the application's endpoints with HTTP Basic authentication.
- {
  "status":401,
  "error":"Unauthorized",
  "message":"Unauthorized",
  "path":"/hello"
  }
- The response status is HTTP 401 Unauthorized. We expected this result as we didn't use the proper credentials for authentication.
- By default, Spring Security expects that default username (user) with the provided password (in my case, the one starting with 93a01)
- Try it again but now with the proper credentials: curl -u user:93a01cf0-794b-4b98-86ef-54860f36f7f3 http://localhost:8080/hello
- The HTTP 401 Unauthorized status code is a bit ambiguous. Usually, it's used to represent a failed authentication rather than authorization. Developer use it in the design of the application for cases like missing or incorrect credentials.
- For a failed authorization, we'd probably use the 403 Forbidden status. Generally, an HTTP 403 means that the server identified the caller of the request, but they don't have the needed privileges for the call that they are trying to make.
- With cURL, you can set the HTTP basic username and password with the -u flag. Behind the scenes, cURL encodes the string <username>:<password> in Base64 and sends it as the value of the Authorization header prefixed with string Basic.
- And with cURL, it's probably easier for you to use the -u flag. But it's also essential to know what the real request looks like.
- First step: take the <username>:<password> string and encode it with Base64. When our application sends the call, we need to know how to form the correct value for the Authorization header. Find a web page that encodes strings in Base64, like https://www.base64encode.org.
- user:93a01cf0-794b-4b98-86ef-54860f36f7f3 will be encoded to dXNlcjo5M2EwMWNmMC03OTRiLTRiOTgtODZlZi01NDg2MGYzNmY3ZjM=
- You can now use the Base64-encoded value as the value of the Authorization header for the call. This call should generate the same result as the one using the -u option
- curl -H "Authorization:  Basic dXNlcjo5M2EwMWNmMC03OTRiLTRiOTgtODZlZi01NDg2MGYzNmY3ZjM=" localhost:8080/hello

## 2. The big picture of Spring Security class design
1. The request is intercepted by the authentication filter.
2. Authentication responsibility is delegated to authentication manager.
3. The authentication manager uses the authentication providers, which implements the authentication logic.
4. The authentication provider finds the user with a "user details service" and validates the password using a password encoder.
5. The result of the authentication is returned to the filter
6. Details about the authenticated entity are stored in the security context.
- Explain: The authentication filter delegates the authentication request to the authentication manager and, base on the response, configures the security context.
- The authentication manager uses the authentication provider to process authentication.
- The authentication provider implements the authentication logic.
- The user details service implements user management responsibility, which the authentication provider uses in the authentication logic.
- The password encoder implements password management, which the authentication uses in the authentication logic.
- The security context keeps the authentication data after the authentication process.
- The authentication provider uses these beans (UserDetailService and password encoder) to find users and to check their passwords.
- An object that implements an UserDetailService interface with Spring Security manages the details about users.
- When we use the default implementation provided by Spring Boot. This implementation only registers the default credentials in the internal memory of the application.
- These default credentials are "user" with a default password that is a universally unique identifier (UUID). This default password is randomly generated when Spring context is loaded(at the app startup). At this time, the application writes the password to console where you can see it.
- The implementation stores the credentials in-memory - The application doesn't persist the credentials.
- This approach is suitable for examples or proof of concepts, but you should avoid it in production ready application.
- We have the PasswordEncoder. The PasswordEncoder does two things: 
  - Encodes a password (usually using an encryption or a hashing algorithm)
  - Verifies if the password matches an existing encoding.
  - The PasswordEncoder is mandatory for the Basic authentication flow. The simplest implementation manages the passwords in plain text and doesn't encode these.
  - When we replace the default implementation of the UserDetailsService, we must also specify a PasswordEncoder.
  - Spring Boot also chooses an authentication method when configuring the defaults, HTTP Basic access authentication. It's the most straightforward access authentication method.
    - Basic authentication only requires the client to send a username and a password though the HTTP Authorization header. In the value of the header, the client attaches the prefix Basic, followed by the Base64 encoding of the string that contains the username and password, separated by colon(:)
    - ## Note: HTTP Basic authentication doesn't offer confidentiality of the credentials. Base64 is only an encoding method for convenience of the transfer; it's not an encryption or hashing method. While in transit, if intercepted, anyone can see the credentials. Generally, we don't use HTTP Basic authentication without at least HTTPS for confidentiality.
- The AuthenticationProvider defines the authentication logic, delegating the user and password management. A default implementation of the AuthenticationProvider uses the default implementations provided for the UserDetailsService and the PasswordEncoder. Implicitly, your application secures all the endpoints.
- **HTTPS**: There are several patters to configure HTTPS in a system. In some case. developers configure HTTPS at the application level; in others, t hey might use a service mesh or they could choose to set HTTPS at the infrastructure level.
  - In any of these configuration scenarios, you need a certificate signed by a certification authority (CA). Using this certificate, the client that calls the endpoint knows whether the response comes from the authentication server and that nobody intercepted the communication.
  - You can buy such a certificate, if you need it. If you only need to configure HTTPS to test your application, you can generate a self-signed certificate using a tool like OpenSSL
    - openssl req -newkey rsa:2048 -x509 -keyout key.pen -out cert.pem
    - After running the openssl command in a terminal, you'll be asked for a password and details about your CA. Because it is only a self-signed certificate for a test, you can input any data there; remember the password
    - The command outputs two files: key.pem (the private key) amd cert.pem (a public certificate). We'll use these files further to generate our self-signed certificate for enabling HTTPS.
    - In most cases, the certificate is the Public Key Cryptography Standards #12 (PKCS12). Less frequently, we use a Java KeyStore(JKS) format.
      - PKCS12 format: openssl pkcs12 -export -in cert.pem -inkey key.pem -out certificate
      - This second command we use receives as input the two files generated by the first command and outputs the self-signed certificate.
  - Finally, having the self-signed certificate, you can configure HTTPS for your endpoints. Copy the certificate.p12 file into resources folder of the Spring Boot project and add the following lines to your application.properties file:
    - server.ssl.key-store-type=PKCS12
      server.ssl.key-store=classpath:certificate.p12
      server.ssl.key-store-password=secret //# the password was requested in the prompt after running the command for generating the certificate.
  - If you use a self-signed certificate, you should configure the tool you use to make the endpoint call so that it skips testing the authenticity of the certificate.
  - If the tool tests the authenticity of the certificate, it won't recognize it as being authentic, and the call won't work.
  ![img_11.png](img_11.png)
  - With cURL, you can use the -k option to skip testing the authenticity of the certificate:
    - curl -k -u user:c7eaf0ad-25c8-43fd-b215-f97802ff8ce5 https://localhost:8080/helloword
    ![img_12.png](img_12.png)
  - **Remember**: Remember that even if you use HTTPS, the communication between components of your system isn't bulletproof. "I'm not encrypting thí anymore, I use HTTPS!" **This is wrong**
    - While helpful in protecting communication, HTTPS í just one of the bricks of the security wall of a system. Always treat the security of your system with responsibility and take care of all the layers involved in it.
## Objective

This project is designed to showcase how to integrate **Spring Security** into a Spring Boot application to secure RESTful APIs. It includes basic functionalities such as authentication, authorization, and session/cookie management.

## Key Features

- **Authentication**: Implements Username and Password authentication using Spring Security.
- **Authorization**: Role-based access control (RBAC) to restrict access to specific APIs based on user roles (Admin, User).
- **JWT (JSON Web Token)**: Utilizes JWT for managing login sessions, authenticating requests, and securing APIs.
- **HTTP Security Configuration**: Configures Spring Security to protect RESTful endpoints and require authentication for secured APIs.
- **Exception Handling**: Manages and returns appropriate error messages when users attempt to access invalid or unauthorized endpoints.

## Technologies Used

- **Spring Boot**: Framework for building the application.
- **Spring Security**: Security framework for authentication and authorization.
- **JWT**: For token-based authentication.
- **Maven**: For dependency management.

## Getting Started

1. Clone the repository.
2. Navigate to the project directory.
3. Run the application using `mvn spring-boot:run`.
4. Access the APIs as per the provided documentation.

## Contributing

Contributions are welcome! Please create a pull request or open an issue for any enhancements or bug fixes.

## Diagram

![img_8.png](img_8.png)
![img_9.png](img_9.png)
## Tutorial

1. if we use default config of spring security, we need to provide username and password for Basis Auth to use RestController ![img_3.png](img_3.png)
</br>  ![img_4.png](img_4.png) When we use base64 decode, we will receive ![img_5.png](img_5.png) user and the generated security password
</br>   **!!! IMPORTANT: It's just encoding to base64, not encrypting**
</br> If we don't use the generated security password, the response will return a 401 Unauthorized code ![img_2.png](img_2.png)
</br> if you want to modify username and password, just create a bean like this ![img_6.png](img_6.png)
</br> then use can use ![img_7.png](img_7.png) instead of use username and random password default.
## Discuss between encoding, encrypting and hashing function:
1. Encoding is a function is always possible to reverse somehow, it can be just a mathematical transformation that doesn't need a secret to be known and can revert it to find out the input
2. Encrypting is transforming an input into an output but to go back from the output to the input you always a secret. So not everyone is able to find out which was the input after encryption function.
It's still a transformation function. It's a particular encoding, but it implies that you always **need a secret** to go back to the input. The secret is something that not necessarily everyone knows
3. Hashing function: from an input you can always go to an output. But from the output, you can never by any means find the input again. Hash functions are the preferred way to store temporarily or permanently passwords

## IMPORTANT NOTE: SpringDataJpa for column with CamelCase: https://stackoverflow.com/questions/47316832/spring-data-jpa-naming-strategy-using-camel-case answered Jun 8, 2018 at 2:03 by asolakhyan
## Managing users
1. we do have only one authentication manager but can have one or multiple authentication providers
2. UserDetailService and PasswordEncoder are used in DaoAuthenticationProvider 
3. GrantedAuthority can be represented as either Authorities or Role
4. Authorities is an action (verb) that the user can do in your application (read, write, delete, execute...)
5. Role is a badge that's usually represented by a subject like admin, manager, client, visitor

### Filter chain
1. Can custom filter in filter chain by implement Filter (no guarantee your custom filter will only be called once) or extend OncePerRequestFilter (if you want to make sure your filter customer will only be called once)
2. 